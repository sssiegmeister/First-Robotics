#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     BR,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     FL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     winch,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    clamp,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"//Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-sensormux.h"
#include "AdvancedSensors.c"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/hitechnic-irseeker-v2.h"



  int up = 170; int down = 215; //clamp servos
  float heading;//gyro heading
	float initial;
	float radheading;
	int lastTime = 0;

void initializeRobot()
{
	servo[clamp] = up;
	motor[winch] = 30;
	wait1Msec(200);
	motor[winch] = 10;

	for(int i = 0; i < 100; i++){ //sums up first hundred gyro readings
		initial += SensorValue[S2];
		wait10Msec(1);
	}
	initial = initial / 100;

  return;
}

void move (int speed){
	motor[FR] = speed;
	motor[BR] = speed;
	motor[BL] = speed;
	motor[FL] = speed;
}

void pivot(int speed){//positive values for clockwise
	motor[FL] = speed;
	motor[FR] = -speed;
	motor[BL] = speed;
	motor[BR] = -speed;
}

void strafe(int speed){//positive values for left
	motor[FL] = speed;
	motor[FR] = -speed;
	motor[BL] = -speed;
	motor[BR] = speed;
}

void rotateTo(int new){
	int startHead = heading;
	while(abs(heading - new) > 2){
		if (startHead + 180 > 360)
			startHead -= 360;
		if (startHead + 180 < new){
			pivot(-25);
		}
		else{
			pivot(25);
		}
	}
	move(0);
}
void deposit(){
	ClearTimer(T3);
	while(time1[T3]<4000)
	{
		motor[winch]=100;
		wait1Msec(1);
	}
	move(0);
	wait1Msec(5000);
	ClearTimer(T3);
	while(time1[T3]<4000)
	{
		motor[winch]=-15;
		wait1Msec(1);
	}
}
task robotHeading(){
	ClearTimer(T2); // sets timer to 0
	while(true){
		int currentReading = SensorValue[gyro] - initial; // gets the new sensor reading
		heading += (currentReading) * (time1[T2] - lastTime) * .001; // modifies the header
		lastTime = time1[T2]; // sets the last time for the next reading
		if (time1[T2]>30000){ // this resets the timer after 30 seconds
			ClearTimer(T2);
			lastTime = 0;
		}
		if (heading<0){
			heading += 360;
		}
		if (heading>=360){
			heading -= 360;
		}
		radheading = heading/180*PI; // the heading expressed in radians
		wait10Msec(1); // lets other tasks run
	}
}

task display(){
	while (true){
		eraseDisplay();
		//nxtDisplayCenteredTextLine(0, "Color: %d", c);
		nxtDisplayCenteredTextLine(0, "Heading: %d", heading);
		wait1Msec(20);
	}
}

task main()
{
  initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.
	StartTask(robotHeading);
	StartTask(display);
  int distance = SensorValue[sonar];

  eraseDisplay();
  nxtDisplayCenteredBigTextLine(3, "%d", heading);
	ClearTimer(T1);

  move(-50);
  wait1Msec(1450);//go down ramp backward

  move(0);
  wait1Msec(2500);

  rotateTo(0);

  move(0);
  wait1Msec(10);

  while (distance > 20 && time1[T1] < 10000){//slowly approach goal for a maximum of 6 seconds
  	move(-20);
  	distance = SensorValue[sonar];
	}

	if (distance > 25)
		StopAllTasks();//in case goal is never picked up

	move(0);
  wait10Msec(10);
  servo[clamp] = down;
  wait1Msec(10);

  rotateTo(30);
  wait10Msec(40);

  move(0);
  wait10Msec(10);

  move(50);
  wait1Msec(2000);

  move(0);
  wait10Msec(10);

  rotateTo(180);

  move(0);
  wait10Msec(10);

  move(-25);
  servo[clamp] = up;
  wait10Msec(100);

  move(0);
  wait10Msec(1);

  move(50);
  wait10Msec(60);

  move(0);
  wait10Msec(10);

	rotateTo(0);

	/*while (distance > 20 && time1[T1] < 10000){//slowly approach goal for a maximum of 6 seconds
  	move(-20);
  	distance = SensorValue[sonar];
	}

	if (distance > 25)
		StopAllTasks();//in case goal is never picked up*/

	//deposit();

  while (true)
  {wait10Msec(1);}
}
