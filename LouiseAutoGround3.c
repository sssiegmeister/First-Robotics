#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     Seeker,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     driveFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     driveFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     driveBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     driveBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     arm,           tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     pulley,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/hitechnic-gyro.h"

int speed=100;

const tMUXSensor HTGYRO = msensor_S3_1;
const tMUXSensor LEGOUS = msensor_S3_2;
const tMUXSensor HTCOLOR = msensor_S3_3;

int acS1, acS2, acS3, acS4, acS5 = 0;

float initial; float heading; float radheading; int lastTime = 0;//initial is the initial Gyro readings. heading is the robot's yaw
float FLset; float FRset; // these stand for front right set and front left set, which refer to wheels on the robot
//FL set is the front-left motor and the back-right motor, and FR set is the other two motors
float joyAngle; // angle of the first joystick

void moveDirection(float angle, float magnitude){ // sets the motor sets to move at certain speeds depending on the vector given
	FLset = magnitude * (cos(angle) + sin(angle));
	FRset = magnitude * (sin(angle) - cos(angle));
}

void initializeRobot()
{
	// Finds average base gyro reading
	for(int i = 0; i < 100; i++)
	{ //sums up first hundred gyro readings
		initial += HTGYROreadRot(HTGYRO);
		wait10Msec(1);
	}
	initial = initial / 100; //divides by 100 to find the average reading
  return;
}
task robotHeading(){
	ClearTimer(T2); // sets timer to 0
	while(true)
	{
		int currentReading = HTGYROreadRot(HTGYRO) - initial; // gets the new sensor reading
		heading += (currentReading) * (time1[T2] - lastTime) * .001; // modifies the header
		if(heading>=360)
			heading=heading-360;
		if(heading<=0)
			heading=heading+360;
		lastTime = time1[T2]; // sets the last time for the next reading
		if (time1[T2]>30000)
		{ // this resets the timer after 30 seconds
			ClearTimer(T2);
			lastTime = 0;
		}
		radheading = heading/180*PI; // the heading expressed in radians
		wait10Msec(1); // lets other tasks run
	}
}
task display()
{
	while (true)
	{
		eraseDisplay();
		//nxtDisplayCenteredTextLine(0, "Color: %d", c);
		nxtDisplayCenteredTextLine(2, "Heading: %d", heading);
		//tDisplayCenteredTextLine(1, "joyAngle: %d", joyAngle);
		wait1Msec(20);
	}
}

task IRSweep3
{
	ClearTimer(T1);
	int dist=0;
	bool done=false;
	while(done==false)
	{
		dist = USreadDist(LEGOUS);
		while(dist>50)
		{
			motor[driveFL]=-speed/2;
			motor[driveFR]=speed/2;
			motor[driveBL]=speed/2;
			motor[driveBR]=-speed/2;
			dist = USreadDist(LEGOUS);
			wait1Msec(1);
		}
		/*motor[driveFL]=-speed/2;
		motor[driveFR]=speed/2;
		motor[driveBL]=speed/2;
		motor[driveBR]=-speed/2;
		wait1Msec(100);*/
		while(dist>15)
		{
			motor[driveFL]=-speed/2;
			motor[driveFR]=-speed/2;
			motor[driveBL]=-speed/2;
			motor[driveBR]=-speed/2;
			dist = USreadDist(LEGOUS);
			wait1Msec(1);
		}
		motor[driveFL]=0;
  	motor[driveFR]=0;
		motor[driveBL]=0;
		motor[driveBR]=0;
		wait1Msec(5000);
		motor[driveFL]=speed/2;
		motor[driveFR]=speed/2;
		motor[driveBL]=speed/2;
		motor[driveBR]=speed/2;
		wait1Msec(150);
		while(heading<265||heading>275)
		{
			motor[driveFL]=-speed/2;
  		motor[driveFR]=speed/2;
			motor[driveBL]=-speed/2;
			motor[driveBR]=speed/2;
			//wait1Msec(600);
		}
		motor[driveFL]=-speed;
  	motor[driveFR]=-speed;
		motor[driveBL]=-speed;
		motor[driveBR]=-speed;
		wait1Msec(2000);
		done=true;
		/*motor[driveFL]=speed;
	  motor[driveFR]=-speed;
	 	motor[driveBL]=-speed;
	 	motor[driveBR]=speed;
  	wait1Msec(1000);
  	motor[driveFL]=-speed;
	 	motor[driveFR]=speed;
	 	motor[driveBL]=speed;
  	motor[driveBR]=-speed;
  	wait1Msec(2000);*/
		/*HTIRS2readAllACStrength(Seeker, acS1, acS2, acS3, acS4, acS5);
		if((acS4-acS3)<40&&(acS4+acS3)>60)
		{
			PlaySound(soundBeepBeep);
			motor[driveFL]=-speed;
			motor[driveFR]=-speed;
			motor[driveBL]=-speed;
			motor[driveBR]=-speed;
			wait1Msec(500);
			motor[driveFL]=-speed;
			motor[driveFR]=speed;
			motor[driveBL]=speed;
			motor[driveBR]=-speed;
			wait1Msec(4000);
		}*/
	}
	StopAllTasks();
}
task IRSweep2
{
	ClearTimer(T1);
	int dist=0;
	while(time1[T1]<1000)
	{
		motor[driveFL]=speed/2;
		motor[driveFR]=-speed/2;
		motor[driveBL]=-speed/2;
		motor[driveBR]=speed/2;
		dist = USreadDist(LEGOUS);
	  HTIRS2readAllACStrength(Seeker, acS1, acS2, acS3, acS4, acS5);
	  if((acS4-acS3)<70&&(acS4+acS3)>30)
	  {
	  	PlaySound(soundBeepBeep);
	  	while(dist>32)
			{
				motor[driveFL]=-speed/4;
				motor[driveFR]=-speed/4;
				motor[driveBL]=-speed/4;
				motor[driveBR]=-speed/4;
				dist=USreadDist(LEGOUS);
				wait1Msec(1);
			}
			motor[driveFL]=0;
			motor[driveFR]=0;
			motor[driveBL]=0;
			motor[driveBR]=0;
			wait1Msec(5000);
			motor[driveFL]=speed/2;
			motor[driveFR]=speed/2;
			motor[driveBL]=speed/2;
			motor[driveBR]=speed/2;
			wait1Msec(200);
	  	motor[driveFL]=-speed;
	  	motor[driveFR]=speed;
	  	motor[driveBL]=speed;
	  	motor[driveBR]=-speed;
	  	wait1Msec(500);
	  	/*motor[driveFL]=-speed;
	  	motor[driveFR]=speed;
	  	motor[driveBL]=-speed;
	  	motor[driveBR]=speed;
	  	wait1Msec(1200);*/
	  	while(heading<40||heading>50)
	  	{
	  		motor[driveFL]=-speed;
	  		motor[driveFR]=speed;
	  		motor[driveBL]=-speed;
	  		motor[driveBR]=speed;
	  	}
	  	motor[driveFL]=-speed;
	  	motor[driveFR]=-speed;
	  	motor[driveBL]=-speed;
	  	motor[driveBR]=-speed;
	  	wait1Msec(2500);
	  	/*motor[driveFL]=speed;
	  	motor[driveFR]=-speed;
	  	motor[driveBL]=-speed;
	  	motor[driveBR]=speed;
	  	wait1Msec(1000);
	  	motor[driveFL]=-speed;
	  	motor[driveFR]=speed;
	  	motor[driveBL]=speed;
	  	motor[driveBR]=-speed;
	  	wait1Msec(2000);*/
	  	StopAllTasks();
	  }
	}
	motor[driveFL]=speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=speed/2;
	wait1Msec(1500);
	motor[driveFL]=-speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(900);
	StartTask(IRSweep3);
}


task IRSweep1
{
	ClearTimer(T1);
	int dist=0;
	while(time1[T1]<1000)
	{
		motor[driveFL]=speed/2;
		motor[driveFR]=-speed/2;
		motor[driveBL]=-speed/2;
		motor[driveBR]=speed/2;
		dist = USreadDist(LEGOUS);
		HTIRS2readAllACStrength(Seeker, acS1, acS2, acS3, acS4, acS5);
		if((acS4-acS3)<70&&(acS4+acS3)>30&&time1[T1]>1000)
		{
			PlaySound(soundBeepBeep);
			motor[driveFL]=-speed/2;
			motor[driveFR]=speed/2;
			motor[driveBL]=speed/2;
			motor[driveBR]=-speed/2;
			wait1Msec(250);
			while(dist>28)
			{
				motor[driveFL]=-speed/4;
				motor[driveFR]=-speed/4;
				motor[driveBL]=-speed/4;
				motor[driveBR]=-speed/4;
				dist=USreadDist(LEGOUS);
				wait1Msec(1);
			}
			/*motor[driveFL]=speed/2;
			motor[driveFR]=-speed/2;
			motor[driveBL]=-speed/2;
			motor[driveBR]=speed/2;
			wait1Msec(200);*/
			motor[driveFL]=0;
			motor[driveFR]=0;
			motor[driveBL]=0;
			motor[driveBR]=0;
			wait1Msec(3000);
			/*motor[arm]=-100;
			wait1Msec(1000);
			motor[pulley]=75;
			wait1Msec(2500);
			motor[pulley]=10;
			servo[door]=150;
			wait1Msec(1500);
			motor[pulley]=-10;
			wait1Msec(1500);*/
			while(dist<100)
			{
				motor[driveFL]=-speed/2;
				motor[driveFR]=speed/2;
				motor[driveBL]=speed/2;
				motor[driveBR]=-speed/2;
				dist=USreadDist(LEGOUS);
				wait1Msec(1);
			}
			motor[driveFL]=-speed/2;
			motor[driveFR]=speed/2;
			motor[driveBL]=speed/2;
			motor[driveBR]=-speed/2;
			wait1Msec(200);
			motor[driveFL]=-speed;
			motor[driveFR]=-speed;
			motor[driveBL]=-speed;
			motor[driveBR]=-speed;
			wait1Msec(3000);
			/*motor[driveFL]=speed;
	  	motor[driveFR]=speed;
	  	motor[driveBL]=speed;
	  	motor[driveBR]=speed;
	  	wait1Msec(1000);
	  	motor[driveFL]=-speed;
	  	motor[driveFR]=-speed;
	  	motor[driveBL]=-speed;
	  	motor[driveBR]=-speed;
	  	wait1Msec(2000);*/
			StopAllTasks();
		}
	}
	motor[driveFL]=-speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(1);
	StartTask(IRSweep2);
}
task firstMove()
{
	/*motor[driveFL]=-speed/2;
	motor[driveFR]=speed/2;
	motor[driveBL]=speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(2000);
	motor[driveFL]=-speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(750);*/
	motor[driveFL]=0;
	motor[driveFR]=0;
	motor[driveBL]=0;
	motor[driveBR]=0;
	wait1Msec(3000);
	motor[driveFL]=-speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(500);
	motor[driveFL]=0;
	motor[driveFR]=0;
	motor[driveBL]=0;
	motor[driveBR]=0;
	StartTask(IRSweep1);
}
task main()
{
	initializeRobot();
	waitForStart();
	ClearTimer(T1);
	StartTask(firstMove);
	StartTask(robotHeading);
	StartTask(display);
	while(true)
	{
		wait1Msec(1);
	}
}
