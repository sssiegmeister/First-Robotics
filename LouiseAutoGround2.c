#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     Seeker,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     driveFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     driveFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     driveBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     driveBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     arm,           tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     pulley,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/hitechnic-colour-v2.h"

int speed=100;

const tMUXSensor HTCOLOR = msensor_S3_2;
const tMUXSensor LEGOUS = msensor_S3_3;

int acS1, acS2, acS3, acS4, acS5 = 0;



task IRSweep1
{
	ClearTimer(T1);
	int dist=0;
	while(time1[T1]<1000)
	{
		motor[driveFL]=speed/2;
		motor[driveFR]=-speed/2;
		motor[driveBL]=-speed/2;
		motor[driveBR]=speed/2;
		dist = USreadDist(LEGOUS);
		HTIRS2readAllACStrength(Seeker, acS1, acS2, acS3, acS4, acS5);
		if((acS4-acS3)<60&&(acS4+acS3)>40&&time1[T1]>1000)
		{
			PlaySound(soundBeepBeep);
			motor[driveFL]=-speed/2;
			motor[driveFR]=speed/2;
			motor[driveBL]=speed/2;
			motor[driveBR]=-speed/2;
			wait1Msec(250);
			while(dist>28)
			{
				motor[driveFL]=-speed/4;
				motor[driveFR]=-speed/4;
				motor[driveBL]=-speed/4;
				motor[driveBR]=-speed/4;
				dist=USreadDist(LEGOUS);
				wait1Msec(1);
			}
			/*motor[driveFL]=speed/2;
			motor[driveFR]=-speed/2;
			motor[driveBL]=-speed/2;
			motor[driveBR]=speed/2;
			wait1Msec(200);*/
			motor[driveFL]=0;
			motor[driveFR]=0;
			motor[driveBL]=0;
			motor[driveBR]=0;
			wait1Msec(3000);
			/*motor[arm]=-100;
			wait1Msec(1000);
			motor[pulley]=75;
			wait1Msec(2500);
			motor[pulley]=10;
			servo[door]=150;
			wait1Msec(1500);
			motor[pulley]=-10;
			wait1Msec(1500);*/
			while(dist<100)
			{
				motor[driveFL]=-speed/2;
				motor[driveFR]=speed/2;
				motor[driveBL]=speed/2;
				motor[driveBR]=-speed/2;
				dist=USreadDist(LEGOUS);
				wait1Msec(1);
			}
			motor[driveFL]=-speed/2;
			motor[driveFR]=speed/2;
			motor[driveBL]=speed/2;
			motor[driveBR]=-speed/2;
			wait1Msec(200);
			motor[driveFL]=-speed;
			motor[driveFR]=-speed;
			motor[driveBL]=-speed;
			motor[driveBR]=-speed;
			wait1Msec(3000);
			/*motor[driveFL]=speed;
	  	motor[driveFR]=speed;
	  	motor[driveBL]=speed;
	  	motor[driveBR]=speed;
	  	wait1Msec(1000);
	  	motor[driveFL]=-speed;
	  	motor[driveFR]=-speed;
	  	motor[driveBL]=-speed;
	  	motor[driveBR]=-speed;
	  	wait1Msec(2000);*/
			StopAllTasks();
		}
	}
	motor[driveFL]=-speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(1);
	StartTask(IRSweep2);
}
task firstMove()
{
	motor[driveFL]=-speed/2;
	motor[driveFR]=-speed/2;
	motor[driveBL]=-speed/2;
	motor[driveBR]=-speed/2;
	wait1Msec(500);
	motor[driveFL]=0;
	motor[driveFR]=0;
	motor[driveBL]=0;
	motor[driveBR]=0;
	StartTask(IRSweep1);
}
task main()
{
	waitForStart();
	ClearTimer(T1);
	StartTask(firstMove);
	while(true)
	{
		wait1Msec(1);
	}
}
