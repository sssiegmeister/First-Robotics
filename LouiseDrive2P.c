#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     driveFL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     driveFR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     driveBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     driveBR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     sweeper,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     pulley,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     clamp,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     swinger,       tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "AdvancedSensors.c"

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/c
//#pragma config(Motor,  mtr_S1_C4_1,    Collecter,            tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/hitechnic-gyro.h"

const tMUXSensor HTGYRO = msensor_S3_1;
const tMUXSensor LEGOUS = msensor_S3_2;
const tMUXSensor HTCOLOR = msensor_S3_3;

int direction=0;
bool clamped=false;
bool sweeping=false;


float initial;
float heading;
float radheading;
int lastTime = 0;//initial is the initial Gyro readings. heading is the robot's yaw
float FLset;
float FRset; // these stand for front right set and front left set, which refer to wheels on the robot
//FL set is the front-left motor and the back-right motor, and FR set is the other two motors
float joyAngle; // angle of the first joystick

void moveDirection(float angle, float magnitude){ // sets the motor sets to move at certain speeds depending on the vector given
	FLset = magnitude * (cos(angle) + sin(angle));
	FRset = magnitude * (sin(angle) - cos(angle));
}

void initializeRobot()
{
	// Finds average base gyro reading
	for(int i = 0; i < 100; i++)
	{ //sums up first hundred gyro readings
		initial += HTGYROreadRot(HTGYRO);
		wait10Msec(1);
	}
	initial = initial / 100; //divides by 100 to find the average reading
  return;
}
task robotHeading(){
	ClearTimer(T1); // sets timer to 0
	while(true)
	{
		int currentReading = HTGYROreadRot(HTGYRO) - initial; // gets the new sensor reading
		heading += (currentReading) * (time1[T1] - lastTime) * .001; // modifies the header
		if(heading>=360)
			heading=heading-360;
		if(heading<=0)
			heading=heading+360;
		lastTime = time1[T1]; // sets the last time for the next reading
		if (time1[T1]>30000)
		{ // this resets the timer after 30 seconds
			ClearTimer(T1);
			lastTime = 0;
		}
		radheading = heading/180*PI; // the heading expressed in radians
		wait10Msec(1); // lets other tasks run
	}
}
task display()
{
	while (true)
	{
		eraseDisplay();
		//nxtDisplayCenteredTextLine(0, "Color: %d", c);
		nxtDisplayCenteredTextLine(2, "Heading: %d", heading);
		//nxtDisplayCenteredTextLine(1, "joyAngle: %d", joyAngle);
		wait1Msec(20);
	}
}
task drive()
{
	while(true)
		{
       	float x1 = joystick.joy1_x1;
       	float y1 = joystick.joy1_y1;
       	float x2 = joystick.joy1_x2;
       	float y2 = joystick.joy1_y2;
       	if(abs(x1)<16)x1=0;
       	if(abs(y1)<16)y1=0;
       	if(abs(x2)<16)x2=0;
       	if(abs(y2)<16)y2=0;
				x1*=.787;
				x2*=.787;
				y1*=.787;
				y2*=.787;

			    int LF = 0;
			    int RF = 0;
			    int LB = 0;
			    int RB = 0;

				  LF += x1;
				  RF -= x1;
			    LB -= x1;
				  RB += x1;

			    LF += y1;
			    RF += y1;
			    LB += y1;
			    RB += y1;

			    LF -= x2;
			    RF += x2;
			    LB -= x2;
			    RB += x2;

       	motor[driveBL] = LB;
       	motor[driveFL] = LF;
       	motor[driveBR] = RB;
       	motor[driveFR] = RF;
				abortTimeslice();
	}
}
task positioning()
{
	while(true)
	{
		if(joy1Btn(6))
		{
			motor[swinger]=40;
			direction=1;
			wait10Msec(1);
		}
		else if(joy1Btn(8))
		{
			motor[swinger]=-40;
			direction=2;
			wait10Msec(1);
		}
		else if(direction==1)
		{
			motor[swinger]=-10;
			wait10Msec(1);
		}
		else if(direction==2)
		{
			motor[swinger]=10;
			wait10Msec(1);
		}
		else
		{
			motor[swinger]=0;
			wait10Msec(1);
		}
		abortTimeslice();
	}
}
task sweep()
{
	while(true)
	{
		if(joy1Btn(2)&&sweeping==false)
		{
			sweeping=true;
			wait10Msec(50);
		}
		if(joy1Btn(2)&&sweeping==true)
		{
			sweeping=false;
			wait10Msec(50);
		}
		while(sweeping==true)
		{
			motor[sweeper]=100;
		}
		while(sweeping==false)
		{
			motor[sweeper]=-100;
		}
		abortTimeslice();
	}
}
/*task release()
{
	while(true)
	{
		if(joy1Btn(4)&&open==true)
		{
			servo[door]=255;
			wait10Msec(50);
			open=false;
		}
		if(joy1Btn(4)&&open==false)
		{
			servo[door]=0;
			wait10Msec(50);
			open=true;
		}
		if(joy2Btn(4)&&open==true)
		{
			servo[door]=255;
			wait10Msec(50);
			open=false;
		}
		if(joy2Btn(4)&&open==false)
		{
			servo[door]=0;
			wait10Msec(50);
			open=true;
		}
		abortTimeslice();
	}
}*/
task raising()
{
	ClearTimer(T1);
	while(true)
	{
		if(joy1Btn(5))
		{
			motor[pulley]=50;
		}
		else if(joy1Btn(7))
		{
			motor[pulley]=-10;
		}
		else if(joy2Btn(6))
		{
			motor[pulley]=100;
		}
		else if(joy2Btn(8))
		{
			motor[pulley]=-10;
		}
		else
		{
			motor[pulley]=0;
		}
		abortTimeslice();
	}
}
task clamping()
{
	while(true)
	{
		/*if(joy1Btn(2)&&clamped==false)
		{
			servo[clamp1]=255;
			wait10Msec(50);
			servo[clamp2]=0;
			wait1Msec(1);
			clamped=true;
		}
		if(joy1Btn(2)&&clamped==true)
		{
			servo[clamp1]=0;
			wait10Msec(50);
			servo[clamp2]=255;
			wait1Msec(1);
			clamped=false;
		}*/
		if(joy1Btn(2)&&clamped==false)
		{
			nMotorEncoder(clamp)=90;
			wait10Msec(50);
			clamped=true;
		}
		if(joy1Btn(2)&&clamped==true)
		{
			nMotorEncoder(clamp)=0;
			wait10Msec(50);
			clamped=true;
		}
		abortTimeslice();
	}
}
task main()
{
	initializeRobot();
	getJoystickSettings (joystick);
	waitForStart();

  StartTask(drive);
  StartTask(raising);
  StartTask(positioning);
  StartTask(clamping);
  StartTask(sweep);
  StartTask(robotHeading);
  StartTask(display);
	while(true)
	{
		wait1Msec(1);
  }
}
